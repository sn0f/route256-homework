package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i route256/checkout/internal/domain/services.CartRepository -o ./mocks\cart_repository_mock.go -n CartRepositoryMock

import (
	"context"
	"route256/checkout/internal/domain"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CartRepositoryMock implements services.CartRepository
type CartRepositoryMock struct {
	t minimock.Tester

	funcAddToCart          func(ctx context.Context, user int64, sku uint32, count uint16) (err error)
	inspectFuncAddToCart   func(ctx context.Context, user int64, sku uint32, count uint16)
	afterAddToCartCounter  uint64
	beforeAddToCartCounter uint64
	AddToCartMock          mCartRepositoryMockAddToCart

	funcClearCart          func(ctx context.Context, user int64) (err error)
	inspectFuncClearCart   func(ctx context.Context, user int64)
	afterClearCartCounter  uint64
	beforeClearCartCounter uint64
	ClearCartMock          mCartRepositoryMockClearCart

	funcDeleteFromCart          func(ctx context.Context, user int64, sku uint32) (err error)
	inspectFuncDeleteFromCart   func(ctx context.Context, user int64, sku uint32)
	afterDeleteFromCartCounter  uint64
	beforeDeleteFromCartCounter uint64
	DeleteFromCartMock          mCartRepositoryMockDeleteFromCart

	funcGetItem          func(ctx context.Context, user int64, sku uint32) (c2 domain.CartItem, err error)
	inspectFuncGetItem   func(ctx context.Context, user int64, sku uint32)
	afterGetItemCounter  uint64
	beforeGetItemCounter uint64
	GetItemMock          mCartRepositoryMockGetItem

	funcListCart          func(ctx context.Context, user int64) (ca1 []domain.CartItem, err error)
	inspectFuncListCart   func(ctx context.Context, user int64)
	afterListCartCounter  uint64
	beforeListCartCounter uint64
	ListCartMock          mCartRepositoryMockListCart

	funcUpdateItemCount          func(ctx context.Context, user int64, sku uint32, count uint16) (err error)
	inspectFuncUpdateItemCount   func(ctx context.Context, user int64, sku uint32, count uint16)
	afterUpdateItemCountCounter  uint64
	beforeUpdateItemCountCounter uint64
	UpdateItemCountMock          mCartRepositoryMockUpdateItemCount
}

// NewCartRepositoryMock returns a mock for services.CartRepository
func NewCartRepositoryMock(t minimock.Tester) *CartRepositoryMock {
	m := &CartRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddToCartMock = mCartRepositoryMockAddToCart{mock: m}
	m.AddToCartMock.callArgs = []*CartRepositoryMockAddToCartParams{}

	m.ClearCartMock = mCartRepositoryMockClearCart{mock: m}
	m.ClearCartMock.callArgs = []*CartRepositoryMockClearCartParams{}

	m.DeleteFromCartMock = mCartRepositoryMockDeleteFromCart{mock: m}
	m.DeleteFromCartMock.callArgs = []*CartRepositoryMockDeleteFromCartParams{}

	m.GetItemMock = mCartRepositoryMockGetItem{mock: m}
	m.GetItemMock.callArgs = []*CartRepositoryMockGetItemParams{}

	m.ListCartMock = mCartRepositoryMockListCart{mock: m}
	m.ListCartMock.callArgs = []*CartRepositoryMockListCartParams{}

	m.UpdateItemCountMock = mCartRepositoryMockUpdateItemCount{mock: m}
	m.UpdateItemCountMock.callArgs = []*CartRepositoryMockUpdateItemCountParams{}

	return m
}

type mCartRepositoryMockAddToCart struct {
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockAddToCartExpectation
	expectations       []*CartRepositoryMockAddToCartExpectation

	callArgs []*CartRepositoryMockAddToCartParams
	mutex    sync.RWMutex
}

// CartRepositoryMockAddToCartExpectation specifies expectation struct of the CartRepository.AddToCart
type CartRepositoryMockAddToCartExpectation struct {
	mock    *CartRepositoryMock
	params  *CartRepositoryMockAddToCartParams
	results *CartRepositoryMockAddToCartResults
	Counter uint64
}

// CartRepositoryMockAddToCartParams contains parameters of the CartRepository.AddToCart
type CartRepositoryMockAddToCartParams struct {
	ctx   context.Context
	user  int64
	sku   uint32
	count uint16
}

// CartRepositoryMockAddToCartResults contains results of the CartRepository.AddToCart
type CartRepositoryMockAddToCartResults struct {
	err error
}

// Expect sets up expected params for CartRepository.AddToCart
func (mmAddToCart *mCartRepositoryMockAddToCart) Expect(ctx context.Context, user int64, sku uint32, count uint16) *mCartRepositoryMockAddToCart {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CartRepositoryMock.AddToCart mock is already set by Set")
	}

	if mmAddToCart.defaultExpectation == nil {
		mmAddToCart.defaultExpectation = &CartRepositoryMockAddToCartExpectation{}
	}

	mmAddToCart.defaultExpectation.params = &CartRepositoryMockAddToCartParams{ctx, user, sku, count}
	for _, e := range mmAddToCart.expectations {
		if minimock.Equal(e.params, mmAddToCart.defaultExpectation.params) {
			mmAddToCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddToCart.defaultExpectation.params)
		}
	}

	return mmAddToCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.AddToCart
func (mmAddToCart *mCartRepositoryMockAddToCart) Inspect(f func(ctx context.Context, user int64, sku uint32, count uint16)) *mCartRepositoryMockAddToCart {
	if mmAddToCart.mock.inspectFuncAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.AddToCart")
	}

	mmAddToCart.mock.inspectFuncAddToCart = f

	return mmAddToCart
}

// Return sets up results that will be returned by CartRepository.AddToCart
func (mmAddToCart *mCartRepositoryMockAddToCart) Return(err error) *CartRepositoryMock {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CartRepositoryMock.AddToCart mock is already set by Set")
	}

	if mmAddToCart.defaultExpectation == nil {
		mmAddToCart.defaultExpectation = &CartRepositoryMockAddToCartExpectation{mock: mmAddToCart.mock}
	}
	mmAddToCart.defaultExpectation.results = &CartRepositoryMockAddToCartResults{err}
	return mmAddToCart.mock
}

// Set uses given function f to mock the CartRepository.AddToCart method
func (mmAddToCart *mCartRepositoryMockAddToCart) Set(f func(ctx context.Context, user int64, sku uint32, count uint16) (err error)) *CartRepositoryMock {
	if mmAddToCart.defaultExpectation != nil {
		mmAddToCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.AddToCart method")
	}

	if len(mmAddToCart.expectations) > 0 {
		mmAddToCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.AddToCart method")
	}

	mmAddToCart.mock.funcAddToCart = f
	return mmAddToCart.mock
}

// When sets expectation for the CartRepository.AddToCart which will trigger the result defined by the following
// Then helper
func (mmAddToCart *mCartRepositoryMockAddToCart) When(ctx context.Context, user int64, sku uint32, count uint16) *CartRepositoryMockAddToCartExpectation {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CartRepositoryMock.AddToCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockAddToCartExpectation{
		mock:   mmAddToCart.mock,
		params: &CartRepositoryMockAddToCartParams{ctx, user, sku, count},
	}
	mmAddToCart.expectations = append(mmAddToCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.AddToCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockAddToCartExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockAddToCartResults{err}
	return e.mock
}

// AddToCart implements services.CartRepository
func (mmAddToCart *CartRepositoryMock) AddToCart(ctx context.Context, user int64, sku uint32, count uint16) (err error) {
	mm_atomic.AddUint64(&mmAddToCart.beforeAddToCartCounter, 1)
	defer mm_atomic.AddUint64(&mmAddToCart.afterAddToCartCounter, 1)

	if mmAddToCart.inspectFuncAddToCart != nil {
		mmAddToCart.inspectFuncAddToCart(ctx, user, sku, count)
	}

	mm_params := &CartRepositoryMockAddToCartParams{ctx, user, sku, count}

	// Record call args
	mmAddToCart.AddToCartMock.mutex.Lock()
	mmAddToCart.AddToCartMock.callArgs = append(mmAddToCart.AddToCartMock.callArgs, mm_params)
	mmAddToCart.AddToCartMock.mutex.Unlock()

	for _, e := range mmAddToCart.AddToCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddToCart.AddToCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddToCart.AddToCartMock.defaultExpectation.Counter, 1)
		mm_want := mmAddToCart.AddToCartMock.defaultExpectation.params
		mm_got := CartRepositoryMockAddToCartParams{ctx, user, sku, count}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddToCart.t.Errorf("CartRepositoryMock.AddToCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddToCart.AddToCartMock.defaultExpectation.results
		if mm_results == nil {
			mmAddToCart.t.Fatal("No results are set for the CartRepositoryMock.AddToCart")
		}
		return (*mm_results).err
	}
	if mmAddToCart.funcAddToCart != nil {
		return mmAddToCart.funcAddToCart(ctx, user, sku, count)
	}
	mmAddToCart.t.Fatalf("Unexpected call to CartRepositoryMock.AddToCart. %v %v %v %v", ctx, user, sku, count)
	return
}

// AddToCartAfterCounter returns a count of finished CartRepositoryMock.AddToCart invocations
func (mmAddToCart *CartRepositoryMock) AddToCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToCart.afterAddToCartCounter)
}

// AddToCartBeforeCounter returns a count of CartRepositoryMock.AddToCart invocations
func (mmAddToCart *CartRepositoryMock) AddToCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToCart.beforeAddToCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.AddToCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddToCart *mCartRepositoryMockAddToCart) Calls() []*CartRepositoryMockAddToCartParams {
	mmAddToCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockAddToCartParams, len(mmAddToCart.callArgs))
	copy(argCopy, mmAddToCart.callArgs)

	mmAddToCart.mutex.RUnlock()

	return argCopy
}

// MinimockAddToCartDone returns true if the count of the AddToCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockAddToCartDone() bool {
	for _, e := range m.AddToCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddToCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToCart != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddToCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockAddToCartInspect() {
	for _, e := range m.AddToCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.AddToCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddToCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		if m.AddToCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepositoryMock.AddToCart")
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.AddToCart with params: %#v", *m.AddToCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToCart != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		m.t.Error("Expected call to CartRepositoryMock.AddToCart")
	}
}

type mCartRepositoryMockClearCart struct {
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockClearCartExpectation
	expectations       []*CartRepositoryMockClearCartExpectation

	callArgs []*CartRepositoryMockClearCartParams
	mutex    sync.RWMutex
}

// CartRepositoryMockClearCartExpectation specifies expectation struct of the CartRepository.ClearCart
type CartRepositoryMockClearCartExpectation struct {
	mock    *CartRepositoryMock
	params  *CartRepositoryMockClearCartParams
	results *CartRepositoryMockClearCartResults
	Counter uint64
}

// CartRepositoryMockClearCartParams contains parameters of the CartRepository.ClearCart
type CartRepositoryMockClearCartParams struct {
	ctx  context.Context
	user int64
}

// CartRepositoryMockClearCartResults contains results of the CartRepository.ClearCart
type CartRepositoryMockClearCartResults struct {
	err error
}

// Expect sets up expected params for CartRepository.ClearCart
func (mmClearCart *mCartRepositoryMockClearCart) Expect(ctx context.Context, user int64) *mCartRepositoryMockClearCart {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Set")
	}

	if mmClearCart.defaultExpectation == nil {
		mmClearCart.defaultExpectation = &CartRepositoryMockClearCartExpectation{}
	}

	mmClearCart.defaultExpectation.params = &CartRepositoryMockClearCartParams{ctx, user}
	for _, e := range mmClearCart.expectations {
		if minimock.Equal(e.params, mmClearCart.defaultExpectation.params) {
			mmClearCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmClearCart.defaultExpectation.params)
		}
	}

	return mmClearCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.ClearCart
func (mmClearCart *mCartRepositoryMockClearCart) Inspect(f func(ctx context.Context, user int64)) *mCartRepositoryMockClearCart {
	if mmClearCart.mock.inspectFuncClearCart != nil {
		mmClearCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.ClearCart")
	}

	mmClearCart.mock.inspectFuncClearCart = f

	return mmClearCart
}

// Return sets up results that will be returned by CartRepository.ClearCart
func (mmClearCart *mCartRepositoryMockClearCart) Return(err error) *CartRepositoryMock {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Set")
	}

	if mmClearCart.defaultExpectation == nil {
		mmClearCart.defaultExpectation = &CartRepositoryMockClearCartExpectation{mock: mmClearCart.mock}
	}
	mmClearCart.defaultExpectation.results = &CartRepositoryMockClearCartResults{err}
	return mmClearCart.mock
}

// Set uses given function f to mock the CartRepository.ClearCart method
func (mmClearCart *mCartRepositoryMockClearCart) Set(f func(ctx context.Context, user int64) (err error)) *CartRepositoryMock {
	if mmClearCart.defaultExpectation != nil {
		mmClearCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.ClearCart method")
	}

	if len(mmClearCart.expectations) > 0 {
		mmClearCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.ClearCart method")
	}

	mmClearCart.mock.funcClearCart = f
	return mmClearCart.mock
}

// When sets expectation for the CartRepository.ClearCart which will trigger the result defined by the following
// Then helper
func (mmClearCart *mCartRepositoryMockClearCart) When(ctx context.Context, user int64) *CartRepositoryMockClearCartExpectation {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CartRepositoryMock.ClearCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockClearCartExpectation{
		mock:   mmClearCart.mock,
		params: &CartRepositoryMockClearCartParams{ctx, user},
	}
	mmClearCart.expectations = append(mmClearCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.ClearCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockClearCartExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockClearCartResults{err}
	return e.mock
}

// ClearCart implements services.CartRepository
func (mmClearCart *CartRepositoryMock) ClearCart(ctx context.Context, user int64) (err error) {
	mm_atomic.AddUint64(&mmClearCart.beforeClearCartCounter, 1)
	defer mm_atomic.AddUint64(&mmClearCart.afterClearCartCounter, 1)

	if mmClearCart.inspectFuncClearCart != nil {
		mmClearCart.inspectFuncClearCart(ctx, user)
	}

	mm_params := &CartRepositoryMockClearCartParams{ctx, user}

	// Record call args
	mmClearCart.ClearCartMock.mutex.Lock()
	mmClearCart.ClearCartMock.callArgs = append(mmClearCart.ClearCartMock.callArgs, mm_params)
	mmClearCart.ClearCartMock.mutex.Unlock()

	for _, e := range mmClearCart.ClearCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmClearCart.ClearCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClearCart.ClearCartMock.defaultExpectation.Counter, 1)
		mm_want := mmClearCart.ClearCartMock.defaultExpectation.params
		mm_got := CartRepositoryMockClearCartParams{ctx, user}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmClearCart.t.Errorf("CartRepositoryMock.ClearCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmClearCart.ClearCartMock.defaultExpectation.results
		if mm_results == nil {
			mmClearCart.t.Fatal("No results are set for the CartRepositoryMock.ClearCart")
		}
		return (*mm_results).err
	}
	if mmClearCart.funcClearCart != nil {
		return mmClearCart.funcClearCart(ctx, user)
	}
	mmClearCart.t.Fatalf("Unexpected call to CartRepositoryMock.ClearCart. %v %v", ctx, user)
	return
}

// ClearCartAfterCounter returns a count of finished CartRepositoryMock.ClearCart invocations
func (mmClearCart *CartRepositoryMock) ClearCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearCart.afterClearCartCounter)
}

// ClearCartBeforeCounter returns a count of CartRepositoryMock.ClearCart invocations
func (mmClearCart *CartRepositoryMock) ClearCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearCart.beforeClearCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.ClearCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmClearCart *mCartRepositoryMockClearCart) Calls() []*CartRepositoryMockClearCartParams {
	mmClearCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockClearCartParams, len(mmClearCart.callArgs))
	copy(argCopy, mmClearCart.callArgs)

	mmClearCart.mutex.RUnlock()

	return argCopy
}

// MinimockClearCartDone returns true if the count of the ClearCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockClearCartDone() bool {
	for _, e := range m.ClearCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ClearCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterClearCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClearCart != nil && mm_atomic.LoadUint64(&m.afterClearCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockClearCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockClearCartInspect() {
	for _, e := range m.ClearCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.ClearCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ClearCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterClearCartCounter) < 1 {
		if m.ClearCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepositoryMock.ClearCart")
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.ClearCart with params: %#v", *m.ClearCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClearCart != nil && mm_atomic.LoadUint64(&m.afterClearCartCounter) < 1 {
		m.t.Error("Expected call to CartRepositoryMock.ClearCart")
	}
}

type mCartRepositoryMockDeleteFromCart struct {
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockDeleteFromCartExpectation
	expectations       []*CartRepositoryMockDeleteFromCartExpectation

	callArgs []*CartRepositoryMockDeleteFromCartParams
	mutex    sync.RWMutex
}

// CartRepositoryMockDeleteFromCartExpectation specifies expectation struct of the CartRepository.DeleteFromCart
type CartRepositoryMockDeleteFromCartExpectation struct {
	mock    *CartRepositoryMock
	params  *CartRepositoryMockDeleteFromCartParams
	results *CartRepositoryMockDeleteFromCartResults
	Counter uint64
}

// CartRepositoryMockDeleteFromCartParams contains parameters of the CartRepository.DeleteFromCart
type CartRepositoryMockDeleteFromCartParams struct {
	ctx  context.Context
	user int64
	sku  uint32
}

// CartRepositoryMockDeleteFromCartResults contains results of the CartRepository.DeleteFromCart
type CartRepositoryMockDeleteFromCartResults struct {
	err error
}

// Expect sets up expected params for CartRepository.DeleteFromCart
func (mmDeleteFromCart *mCartRepositoryMockDeleteFromCart) Expect(ctx context.Context, user int64, sku uint32) *mCartRepositoryMockDeleteFromCart {
	if mmDeleteFromCart.mock.funcDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("CartRepositoryMock.DeleteFromCart mock is already set by Set")
	}

	if mmDeleteFromCart.defaultExpectation == nil {
		mmDeleteFromCart.defaultExpectation = &CartRepositoryMockDeleteFromCartExpectation{}
	}

	mmDeleteFromCart.defaultExpectation.params = &CartRepositoryMockDeleteFromCartParams{ctx, user, sku}
	for _, e := range mmDeleteFromCart.expectations {
		if minimock.Equal(e.params, mmDeleteFromCart.defaultExpectation.params) {
			mmDeleteFromCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteFromCart.defaultExpectation.params)
		}
	}

	return mmDeleteFromCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.DeleteFromCart
func (mmDeleteFromCart *mCartRepositoryMockDeleteFromCart) Inspect(f func(ctx context.Context, user int64, sku uint32)) *mCartRepositoryMockDeleteFromCart {
	if mmDeleteFromCart.mock.inspectFuncDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.DeleteFromCart")
	}

	mmDeleteFromCart.mock.inspectFuncDeleteFromCart = f

	return mmDeleteFromCart
}

// Return sets up results that will be returned by CartRepository.DeleteFromCart
func (mmDeleteFromCart *mCartRepositoryMockDeleteFromCart) Return(err error) *CartRepositoryMock {
	if mmDeleteFromCart.mock.funcDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("CartRepositoryMock.DeleteFromCart mock is already set by Set")
	}

	if mmDeleteFromCart.defaultExpectation == nil {
		mmDeleteFromCart.defaultExpectation = &CartRepositoryMockDeleteFromCartExpectation{mock: mmDeleteFromCart.mock}
	}
	mmDeleteFromCart.defaultExpectation.results = &CartRepositoryMockDeleteFromCartResults{err}
	return mmDeleteFromCart.mock
}

// Set uses given function f to mock the CartRepository.DeleteFromCart method
func (mmDeleteFromCart *mCartRepositoryMockDeleteFromCart) Set(f func(ctx context.Context, user int64, sku uint32) (err error)) *CartRepositoryMock {
	if mmDeleteFromCart.defaultExpectation != nil {
		mmDeleteFromCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.DeleteFromCart method")
	}

	if len(mmDeleteFromCart.expectations) > 0 {
		mmDeleteFromCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.DeleteFromCart method")
	}

	mmDeleteFromCart.mock.funcDeleteFromCart = f
	return mmDeleteFromCart.mock
}

// When sets expectation for the CartRepository.DeleteFromCart which will trigger the result defined by the following
// Then helper
func (mmDeleteFromCart *mCartRepositoryMockDeleteFromCart) When(ctx context.Context, user int64, sku uint32) *CartRepositoryMockDeleteFromCartExpectation {
	if mmDeleteFromCart.mock.funcDeleteFromCart != nil {
		mmDeleteFromCart.mock.t.Fatalf("CartRepositoryMock.DeleteFromCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockDeleteFromCartExpectation{
		mock:   mmDeleteFromCart.mock,
		params: &CartRepositoryMockDeleteFromCartParams{ctx, user, sku},
	}
	mmDeleteFromCart.expectations = append(mmDeleteFromCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.DeleteFromCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockDeleteFromCartExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockDeleteFromCartResults{err}
	return e.mock
}

// DeleteFromCart implements services.CartRepository
func (mmDeleteFromCart *CartRepositoryMock) DeleteFromCart(ctx context.Context, user int64, sku uint32) (err error) {
	mm_atomic.AddUint64(&mmDeleteFromCart.beforeDeleteFromCartCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteFromCart.afterDeleteFromCartCounter, 1)

	if mmDeleteFromCart.inspectFuncDeleteFromCart != nil {
		mmDeleteFromCart.inspectFuncDeleteFromCart(ctx, user, sku)
	}

	mm_params := &CartRepositoryMockDeleteFromCartParams{ctx, user, sku}

	// Record call args
	mmDeleteFromCart.DeleteFromCartMock.mutex.Lock()
	mmDeleteFromCart.DeleteFromCartMock.callArgs = append(mmDeleteFromCart.DeleteFromCartMock.callArgs, mm_params)
	mmDeleteFromCart.DeleteFromCartMock.mutex.Unlock()

	for _, e := range mmDeleteFromCart.DeleteFromCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteFromCart.DeleteFromCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.params
		mm_got := CartRepositoryMockDeleteFromCartParams{ctx, user, sku}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteFromCart.t.Errorf("CartRepositoryMock.DeleteFromCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteFromCart.DeleteFromCartMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteFromCart.t.Fatal("No results are set for the CartRepositoryMock.DeleteFromCart")
		}
		return (*mm_results).err
	}
	if mmDeleteFromCart.funcDeleteFromCart != nil {
		return mmDeleteFromCart.funcDeleteFromCart(ctx, user, sku)
	}
	mmDeleteFromCart.t.Fatalf("Unexpected call to CartRepositoryMock.DeleteFromCart. %v %v %v", ctx, user, sku)
	return
}

// DeleteFromCartAfterCounter returns a count of finished CartRepositoryMock.DeleteFromCart invocations
func (mmDeleteFromCart *CartRepositoryMock) DeleteFromCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFromCart.afterDeleteFromCartCounter)
}

// DeleteFromCartBeforeCounter returns a count of CartRepositoryMock.DeleteFromCart invocations
func (mmDeleteFromCart *CartRepositoryMock) DeleteFromCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFromCart.beforeDeleteFromCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.DeleteFromCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteFromCart *mCartRepositoryMockDeleteFromCart) Calls() []*CartRepositoryMockDeleteFromCartParams {
	mmDeleteFromCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockDeleteFromCartParams, len(mmDeleteFromCart.callArgs))
	copy(argCopy, mmDeleteFromCart.callArgs)

	mmDeleteFromCart.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteFromCartDone returns true if the count of the DeleteFromCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockDeleteFromCartDone() bool {
	for _, e := range m.DeleteFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFromCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFromCart != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteFromCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockDeleteFromCartInspect() {
	for _, e := range m.DeleteFromCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteFromCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFromCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		if m.DeleteFromCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepositoryMock.DeleteFromCart")
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteFromCart with params: %#v", *m.DeleteFromCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFromCart != nil && mm_atomic.LoadUint64(&m.afterDeleteFromCartCounter) < 1 {
		m.t.Error("Expected call to CartRepositoryMock.DeleteFromCart")
	}
}

type mCartRepositoryMockGetItem struct {
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockGetItemExpectation
	expectations       []*CartRepositoryMockGetItemExpectation

	callArgs []*CartRepositoryMockGetItemParams
	mutex    sync.RWMutex
}

// CartRepositoryMockGetItemExpectation specifies expectation struct of the CartRepository.GetItem
type CartRepositoryMockGetItemExpectation struct {
	mock    *CartRepositoryMock
	params  *CartRepositoryMockGetItemParams
	results *CartRepositoryMockGetItemResults
	Counter uint64
}

// CartRepositoryMockGetItemParams contains parameters of the CartRepository.GetItem
type CartRepositoryMockGetItemParams struct {
	ctx  context.Context
	user int64
	sku  uint32
}

// CartRepositoryMockGetItemResults contains results of the CartRepository.GetItem
type CartRepositoryMockGetItemResults struct {
	c2  domain.CartItem
	err error
}

// Expect sets up expected params for CartRepository.GetItem
func (mmGetItem *mCartRepositoryMockGetItem) Expect(ctx context.Context, user int64, sku uint32) *mCartRepositoryMockGetItem {
	if mmGetItem.mock.funcGetItem != nil {
		mmGetItem.mock.t.Fatalf("CartRepositoryMock.GetItem mock is already set by Set")
	}

	if mmGetItem.defaultExpectation == nil {
		mmGetItem.defaultExpectation = &CartRepositoryMockGetItemExpectation{}
	}

	mmGetItem.defaultExpectation.params = &CartRepositoryMockGetItemParams{ctx, user, sku}
	for _, e := range mmGetItem.expectations {
		if minimock.Equal(e.params, mmGetItem.defaultExpectation.params) {
			mmGetItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetItem.defaultExpectation.params)
		}
	}

	return mmGetItem
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.GetItem
func (mmGetItem *mCartRepositoryMockGetItem) Inspect(f func(ctx context.Context, user int64, sku uint32)) *mCartRepositoryMockGetItem {
	if mmGetItem.mock.inspectFuncGetItem != nil {
		mmGetItem.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.GetItem")
	}

	mmGetItem.mock.inspectFuncGetItem = f

	return mmGetItem
}

// Return sets up results that will be returned by CartRepository.GetItem
func (mmGetItem *mCartRepositoryMockGetItem) Return(c2 domain.CartItem, err error) *CartRepositoryMock {
	if mmGetItem.mock.funcGetItem != nil {
		mmGetItem.mock.t.Fatalf("CartRepositoryMock.GetItem mock is already set by Set")
	}

	if mmGetItem.defaultExpectation == nil {
		mmGetItem.defaultExpectation = &CartRepositoryMockGetItemExpectation{mock: mmGetItem.mock}
	}
	mmGetItem.defaultExpectation.results = &CartRepositoryMockGetItemResults{c2, err}
	return mmGetItem.mock
}

// Set uses given function f to mock the CartRepository.GetItem method
func (mmGetItem *mCartRepositoryMockGetItem) Set(f func(ctx context.Context, user int64, sku uint32) (c2 domain.CartItem, err error)) *CartRepositoryMock {
	if mmGetItem.defaultExpectation != nil {
		mmGetItem.mock.t.Fatalf("Default expectation is already set for the CartRepository.GetItem method")
	}

	if len(mmGetItem.expectations) > 0 {
		mmGetItem.mock.t.Fatalf("Some expectations are already set for the CartRepository.GetItem method")
	}

	mmGetItem.mock.funcGetItem = f
	return mmGetItem.mock
}

// When sets expectation for the CartRepository.GetItem which will trigger the result defined by the following
// Then helper
func (mmGetItem *mCartRepositoryMockGetItem) When(ctx context.Context, user int64, sku uint32) *CartRepositoryMockGetItemExpectation {
	if mmGetItem.mock.funcGetItem != nil {
		mmGetItem.mock.t.Fatalf("CartRepositoryMock.GetItem mock is already set by Set")
	}

	expectation := &CartRepositoryMockGetItemExpectation{
		mock:   mmGetItem.mock,
		params: &CartRepositoryMockGetItemParams{ctx, user, sku},
	}
	mmGetItem.expectations = append(mmGetItem.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.GetItem return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockGetItemExpectation) Then(c2 domain.CartItem, err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockGetItemResults{c2, err}
	return e.mock
}

// GetItem implements services.CartRepository
func (mmGetItem *CartRepositoryMock) GetItem(ctx context.Context, user int64, sku uint32) (c2 domain.CartItem, err error) {
	mm_atomic.AddUint64(&mmGetItem.beforeGetItemCounter, 1)
	defer mm_atomic.AddUint64(&mmGetItem.afterGetItemCounter, 1)

	if mmGetItem.inspectFuncGetItem != nil {
		mmGetItem.inspectFuncGetItem(ctx, user, sku)
	}

	mm_params := &CartRepositoryMockGetItemParams{ctx, user, sku}

	// Record call args
	mmGetItem.GetItemMock.mutex.Lock()
	mmGetItem.GetItemMock.callArgs = append(mmGetItem.GetItemMock.callArgs, mm_params)
	mmGetItem.GetItemMock.mutex.Unlock()

	for _, e := range mmGetItem.GetItemMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmGetItem.GetItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetItem.GetItemMock.defaultExpectation.Counter, 1)
		mm_want := mmGetItem.GetItemMock.defaultExpectation.params
		mm_got := CartRepositoryMockGetItemParams{ctx, user, sku}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetItem.t.Errorf("CartRepositoryMock.GetItem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetItem.GetItemMock.defaultExpectation.results
		if mm_results == nil {
			mmGetItem.t.Fatal("No results are set for the CartRepositoryMock.GetItem")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmGetItem.funcGetItem != nil {
		return mmGetItem.funcGetItem(ctx, user, sku)
	}
	mmGetItem.t.Fatalf("Unexpected call to CartRepositoryMock.GetItem. %v %v %v", ctx, user, sku)
	return
}

// GetItemAfterCounter returns a count of finished CartRepositoryMock.GetItem invocations
func (mmGetItem *CartRepositoryMock) GetItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItem.afterGetItemCounter)
}

// GetItemBeforeCounter returns a count of CartRepositoryMock.GetItem invocations
func (mmGetItem *CartRepositoryMock) GetItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItem.beforeGetItemCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.GetItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetItem *mCartRepositoryMockGetItem) Calls() []*CartRepositoryMockGetItemParams {
	mmGetItem.mutex.RLock()

	argCopy := make([]*CartRepositoryMockGetItemParams, len(mmGetItem.callArgs))
	copy(argCopy, mmGetItem.callArgs)

	mmGetItem.mutex.RUnlock()

	return argCopy
}

// MinimockGetItemDone returns true if the count of the GetItem invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockGetItemDone() bool {
	for _, e := range m.GetItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetItemCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItem != nil && mm_atomic.LoadUint64(&m.afterGetItemCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetItemInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockGetItemInspect() {
	for _, e := range m.GetItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.GetItem with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetItemCounter) < 1 {
		if m.GetItemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepositoryMock.GetItem")
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.GetItem with params: %#v", *m.GetItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItem != nil && mm_atomic.LoadUint64(&m.afterGetItemCounter) < 1 {
		m.t.Error("Expected call to CartRepositoryMock.GetItem")
	}
}

type mCartRepositoryMockListCart struct {
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockListCartExpectation
	expectations       []*CartRepositoryMockListCartExpectation

	callArgs []*CartRepositoryMockListCartParams
	mutex    sync.RWMutex
}

// CartRepositoryMockListCartExpectation specifies expectation struct of the CartRepository.ListCart
type CartRepositoryMockListCartExpectation struct {
	mock    *CartRepositoryMock
	params  *CartRepositoryMockListCartParams
	results *CartRepositoryMockListCartResults
	Counter uint64
}

// CartRepositoryMockListCartParams contains parameters of the CartRepository.ListCart
type CartRepositoryMockListCartParams struct {
	ctx  context.Context
	user int64
}

// CartRepositoryMockListCartResults contains results of the CartRepository.ListCart
type CartRepositoryMockListCartResults struct {
	ca1 []domain.CartItem
	err error
}

// Expect sets up expected params for CartRepository.ListCart
func (mmListCart *mCartRepositoryMockListCart) Expect(ctx context.Context, user int64) *mCartRepositoryMockListCart {
	if mmListCart.mock.funcListCart != nil {
		mmListCart.mock.t.Fatalf("CartRepositoryMock.ListCart mock is already set by Set")
	}

	if mmListCart.defaultExpectation == nil {
		mmListCart.defaultExpectation = &CartRepositoryMockListCartExpectation{}
	}

	mmListCart.defaultExpectation.params = &CartRepositoryMockListCartParams{ctx, user}
	for _, e := range mmListCart.expectations {
		if minimock.Equal(e.params, mmListCart.defaultExpectation.params) {
			mmListCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListCart.defaultExpectation.params)
		}
	}

	return mmListCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.ListCart
func (mmListCart *mCartRepositoryMockListCart) Inspect(f func(ctx context.Context, user int64)) *mCartRepositoryMockListCart {
	if mmListCart.mock.inspectFuncListCart != nil {
		mmListCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.ListCart")
	}

	mmListCart.mock.inspectFuncListCart = f

	return mmListCart
}

// Return sets up results that will be returned by CartRepository.ListCart
func (mmListCart *mCartRepositoryMockListCart) Return(ca1 []domain.CartItem, err error) *CartRepositoryMock {
	if mmListCart.mock.funcListCart != nil {
		mmListCart.mock.t.Fatalf("CartRepositoryMock.ListCart mock is already set by Set")
	}

	if mmListCart.defaultExpectation == nil {
		mmListCart.defaultExpectation = &CartRepositoryMockListCartExpectation{mock: mmListCart.mock}
	}
	mmListCart.defaultExpectation.results = &CartRepositoryMockListCartResults{ca1, err}
	return mmListCart.mock
}

// Set uses given function f to mock the CartRepository.ListCart method
func (mmListCart *mCartRepositoryMockListCart) Set(f func(ctx context.Context, user int64) (ca1 []domain.CartItem, err error)) *CartRepositoryMock {
	if mmListCart.defaultExpectation != nil {
		mmListCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.ListCart method")
	}

	if len(mmListCart.expectations) > 0 {
		mmListCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.ListCart method")
	}

	mmListCart.mock.funcListCart = f
	return mmListCart.mock
}

// When sets expectation for the CartRepository.ListCart which will trigger the result defined by the following
// Then helper
func (mmListCart *mCartRepositoryMockListCart) When(ctx context.Context, user int64) *CartRepositoryMockListCartExpectation {
	if mmListCart.mock.funcListCart != nil {
		mmListCart.mock.t.Fatalf("CartRepositoryMock.ListCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockListCartExpectation{
		mock:   mmListCart.mock,
		params: &CartRepositoryMockListCartParams{ctx, user},
	}
	mmListCart.expectations = append(mmListCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.ListCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockListCartExpectation) Then(ca1 []domain.CartItem, err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockListCartResults{ca1, err}
	return e.mock
}

// ListCart implements services.CartRepository
func (mmListCart *CartRepositoryMock) ListCart(ctx context.Context, user int64) (ca1 []domain.CartItem, err error) {
	mm_atomic.AddUint64(&mmListCart.beforeListCartCounter, 1)
	defer mm_atomic.AddUint64(&mmListCart.afterListCartCounter, 1)

	if mmListCart.inspectFuncListCart != nil {
		mmListCart.inspectFuncListCart(ctx, user)
	}

	mm_params := &CartRepositoryMockListCartParams{ctx, user}

	// Record call args
	mmListCart.ListCartMock.mutex.Lock()
	mmListCart.ListCartMock.callArgs = append(mmListCart.ListCartMock.callArgs, mm_params)
	mmListCart.ListCartMock.mutex.Unlock()

	for _, e := range mmListCart.ListCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1, e.results.err
		}
	}

	if mmListCart.ListCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListCart.ListCartMock.defaultExpectation.Counter, 1)
		mm_want := mmListCart.ListCartMock.defaultExpectation.params
		mm_got := CartRepositoryMockListCartParams{ctx, user}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListCart.t.Errorf("CartRepositoryMock.ListCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListCart.ListCartMock.defaultExpectation.results
		if mm_results == nil {
			mmListCart.t.Fatal("No results are set for the CartRepositoryMock.ListCart")
		}
		return (*mm_results).ca1, (*mm_results).err
	}
	if mmListCart.funcListCart != nil {
		return mmListCart.funcListCart(ctx, user)
	}
	mmListCart.t.Fatalf("Unexpected call to CartRepositoryMock.ListCart. %v %v", ctx, user)
	return
}

// ListCartAfterCounter returns a count of finished CartRepositoryMock.ListCart invocations
func (mmListCart *CartRepositoryMock) ListCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCart.afterListCartCounter)
}

// ListCartBeforeCounter returns a count of CartRepositoryMock.ListCart invocations
func (mmListCart *CartRepositoryMock) ListCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCart.beforeListCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.ListCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListCart *mCartRepositoryMockListCart) Calls() []*CartRepositoryMockListCartParams {
	mmListCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockListCartParams, len(mmListCart.callArgs))
	copy(argCopy, mmListCart.callArgs)

	mmListCart.mutex.RUnlock()

	return argCopy
}

// MinimockListCartDone returns true if the count of the ListCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockListCartDone() bool {
	for _, e := range m.ListCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListCart != nil && mm_atomic.LoadUint64(&m.afterListCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockListCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockListCartInspect() {
	for _, e := range m.ListCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.ListCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListCartCounter) < 1 {
		if m.ListCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepositoryMock.ListCart")
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.ListCart with params: %#v", *m.ListCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListCart != nil && mm_atomic.LoadUint64(&m.afterListCartCounter) < 1 {
		m.t.Error("Expected call to CartRepositoryMock.ListCart")
	}
}

type mCartRepositoryMockUpdateItemCount struct {
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockUpdateItemCountExpectation
	expectations       []*CartRepositoryMockUpdateItemCountExpectation

	callArgs []*CartRepositoryMockUpdateItemCountParams
	mutex    sync.RWMutex
}

// CartRepositoryMockUpdateItemCountExpectation specifies expectation struct of the CartRepository.UpdateItemCount
type CartRepositoryMockUpdateItemCountExpectation struct {
	mock    *CartRepositoryMock
	params  *CartRepositoryMockUpdateItemCountParams
	results *CartRepositoryMockUpdateItemCountResults
	Counter uint64
}

// CartRepositoryMockUpdateItemCountParams contains parameters of the CartRepository.UpdateItemCount
type CartRepositoryMockUpdateItemCountParams struct {
	ctx   context.Context
	user  int64
	sku   uint32
	count uint16
}

// CartRepositoryMockUpdateItemCountResults contains results of the CartRepository.UpdateItemCount
type CartRepositoryMockUpdateItemCountResults struct {
	err error
}

// Expect sets up expected params for CartRepository.UpdateItemCount
func (mmUpdateItemCount *mCartRepositoryMockUpdateItemCount) Expect(ctx context.Context, user int64, sku uint32, count uint16) *mCartRepositoryMockUpdateItemCount {
	if mmUpdateItemCount.mock.funcUpdateItemCount != nil {
		mmUpdateItemCount.mock.t.Fatalf("CartRepositoryMock.UpdateItemCount mock is already set by Set")
	}

	if mmUpdateItemCount.defaultExpectation == nil {
		mmUpdateItemCount.defaultExpectation = &CartRepositoryMockUpdateItemCountExpectation{}
	}

	mmUpdateItemCount.defaultExpectation.params = &CartRepositoryMockUpdateItemCountParams{ctx, user, sku, count}
	for _, e := range mmUpdateItemCount.expectations {
		if minimock.Equal(e.params, mmUpdateItemCount.defaultExpectation.params) {
			mmUpdateItemCount.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateItemCount.defaultExpectation.params)
		}
	}

	return mmUpdateItemCount
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.UpdateItemCount
func (mmUpdateItemCount *mCartRepositoryMockUpdateItemCount) Inspect(f func(ctx context.Context, user int64, sku uint32, count uint16)) *mCartRepositoryMockUpdateItemCount {
	if mmUpdateItemCount.mock.inspectFuncUpdateItemCount != nil {
		mmUpdateItemCount.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.UpdateItemCount")
	}

	mmUpdateItemCount.mock.inspectFuncUpdateItemCount = f

	return mmUpdateItemCount
}

// Return sets up results that will be returned by CartRepository.UpdateItemCount
func (mmUpdateItemCount *mCartRepositoryMockUpdateItemCount) Return(err error) *CartRepositoryMock {
	if mmUpdateItemCount.mock.funcUpdateItemCount != nil {
		mmUpdateItemCount.mock.t.Fatalf("CartRepositoryMock.UpdateItemCount mock is already set by Set")
	}

	if mmUpdateItemCount.defaultExpectation == nil {
		mmUpdateItemCount.defaultExpectation = &CartRepositoryMockUpdateItemCountExpectation{mock: mmUpdateItemCount.mock}
	}
	mmUpdateItemCount.defaultExpectation.results = &CartRepositoryMockUpdateItemCountResults{err}
	return mmUpdateItemCount.mock
}

// Set uses given function f to mock the CartRepository.UpdateItemCount method
func (mmUpdateItemCount *mCartRepositoryMockUpdateItemCount) Set(f func(ctx context.Context, user int64, sku uint32, count uint16) (err error)) *CartRepositoryMock {
	if mmUpdateItemCount.defaultExpectation != nil {
		mmUpdateItemCount.mock.t.Fatalf("Default expectation is already set for the CartRepository.UpdateItemCount method")
	}

	if len(mmUpdateItemCount.expectations) > 0 {
		mmUpdateItemCount.mock.t.Fatalf("Some expectations are already set for the CartRepository.UpdateItemCount method")
	}

	mmUpdateItemCount.mock.funcUpdateItemCount = f
	return mmUpdateItemCount.mock
}

// When sets expectation for the CartRepository.UpdateItemCount which will trigger the result defined by the following
// Then helper
func (mmUpdateItemCount *mCartRepositoryMockUpdateItemCount) When(ctx context.Context, user int64, sku uint32, count uint16) *CartRepositoryMockUpdateItemCountExpectation {
	if mmUpdateItemCount.mock.funcUpdateItemCount != nil {
		mmUpdateItemCount.mock.t.Fatalf("CartRepositoryMock.UpdateItemCount mock is already set by Set")
	}

	expectation := &CartRepositoryMockUpdateItemCountExpectation{
		mock:   mmUpdateItemCount.mock,
		params: &CartRepositoryMockUpdateItemCountParams{ctx, user, sku, count},
	}
	mmUpdateItemCount.expectations = append(mmUpdateItemCount.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.UpdateItemCount return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockUpdateItemCountExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockUpdateItemCountResults{err}
	return e.mock
}

// UpdateItemCount implements services.CartRepository
func (mmUpdateItemCount *CartRepositoryMock) UpdateItemCount(ctx context.Context, user int64, sku uint32, count uint16) (err error) {
	mm_atomic.AddUint64(&mmUpdateItemCount.beforeUpdateItemCountCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateItemCount.afterUpdateItemCountCounter, 1)

	if mmUpdateItemCount.inspectFuncUpdateItemCount != nil {
		mmUpdateItemCount.inspectFuncUpdateItemCount(ctx, user, sku, count)
	}

	mm_params := &CartRepositoryMockUpdateItemCountParams{ctx, user, sku, count}

	// Record call args
	mmUpdateItemCount.UpdateItemCountMock.mutex.Lock()
	mmUpdateItemCount.UpdateItemCountMock.callArgs = append(mmUpdateItemCount.UpdateItemCountMock.callArgs, mm_params)
	mmUpdateItemCount.UpdateItemCountMock.mutex.Unlock()

	for _, e := range mmUpdateItemCount.UpdateItemCountMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateItemCount.UpdateItemCountMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateItemCount.UpdateItemCountMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateItemCount.UpdateItemCountMock.defaultExpectation.params
		mm_got := CartRepositoryMockUpdateItemCountParams{ctx, user, sku, count}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateItemCount.t.Errorf("CartRepositoryMock.UpdateItemCount got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateItemCount.UpdateItemCountMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateItemCount.t.Fatal("No results are set for the CartRepositoryMock.UpdateItemCount")
		}
		return (*mm_results).err
	}
	if mmUpdateItemCount.funcUpdateItemCount != nil {
		return mmUpdateItemCount.funcUpdateItemCount(ctx, user, sku, count)
	}
	mmUpdateItemCount.t.Fatalf("Unexpected call to CartRepositoryMock.UpdateItemCount. %v %v %v %v", ctx, user, sku, count)
	return
}

// UpdateItemCountAfterCounter returns a count of finished CartRepositoryMock.UpdateItemCount invocations
func (mmUpdateItemCount *CartRepositoryMock) UpdateItemCountAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateItemCount.afterUpdateItemCountCounter)
}

// UpdateItemCountBeforeCounter returns a count of CartRepositoryMock.UpdateItemCount invocations
func (mmUpdateItemCount *CartRepositoryMock) UpdateItemCountBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateItemCount.beforeUpdateItemCountCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.UpdateItemCount.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateItemCount *mCartRepositoryMockUpdateItemCount) Calls() []*CartRepositoryMockUpdateItemCountParams {
	mmUpdateItemCount.mutex.RLock()

	argCopy := make([]*CartRepositoryMockUpdateItemCountParams, len(mmUpdateItemCount.callArgs))
	copy(argCopy, mmUpdateItemCount.callArgs)

	mmUpdateItemCount.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateItemCountDone returns true if the count of the UpdateItemCount invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockUpdateItemCountDone() bool {
	for _, e := range m.UpdateItemCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateItemCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateItemCountCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateItemCount != nil && mm_atomic.LoadUint64(&m.afterUpdateItemCountCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateItemCountInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockUpdateItemCountInspect() {
	for _, e := range m.UpdateItemCountMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.UpdateItemCount with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateItemCountMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateItemCountCounter) < 1 {
		if m.UpdateItemCountMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepositoryMock.UpdateItemCount")
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.UpdateItemCount with params: %#v", *m.UpdateItemCountMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateItemCount != nil && mm_atomic.LoadUint64(&m.afterUpdateItemCountCounter) < 1 {
		m.t.Error("Expected call to CartRepositoryMock.UpdateItemCount")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CartRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddToCartInspect()

		m.MinimockClearCartInspect()

		m.MinimockDeleteFromCartInspect()

		m.MinimockGetItemInspect()

		m.MinimockListCartInspect()

		m.MinimockUpdateItemCountInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CartRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CartRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddToCartDone() &&
		m.MinimockClearCartDone() &&
		m.MinimockDeleteFromCartDone() &&
		m.MinimockGetItemDone() &&
		m.MinimockListCartDone() &&
		m.MinimockUpdateItemCountDone()
}
