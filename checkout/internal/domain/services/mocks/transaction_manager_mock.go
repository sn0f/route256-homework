package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i route256/checkout/internal/domain/services.TransactionManager -o ./mocks\transaction_manager_mock.go -n TransactionManagerMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// TransactionManagerMock implements services.TransactionManager
type TransactionManagerMock struct {
	t minimock.Tester

	funcRunReadCommitted          func(ctx context.Context, fx func(ctxTX context.Context) error) (err error)
	inspectFuncRunReadCommitted   func(ctx context.Context, fx func(ctxTX context.Context) error)
	afterRunReadCommittedCounter  uint64
	beforeRunReadCommittedCounter uint64
	RunReadCommittedMock          mTransactionManagerMockRunReadCommitted

	funcRunRepeatableRead          func(ctx context.Context, fx func(ctxTX context.Context) error) (err error)
	inspectFuncRunRepeatableRead   func(ctx context.Context, fx func(ctxTX context.Context) error)
	afterRunRepeatableReadCounter  uint64
	beforeRunRepeatableReadCounter uint64
	RunRepeatableReadMock          mTransactionManagerMockRunRepeatableRead

	funcRunSerializable          func(ctx context.Context, fx func(ctxTX context.Context) error) (err error)
	inspectFuncRunSerializable   func(ctx context.Context, fx func(ctxTX context.Context) error)
	afterRunSerializableCounter  uint64
	beforeRunSerializableCounter uint64
	RunSerializableMock          mTransactionManagerMockRunSerializable
}

// NewTransactionManagerMock returns a mock for services.TransactionManager
func NewTransactionManagerMock(t minimock.Tester) *TransactionManagerMock {
	m := &TransactionManagerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.RunReadCommittedMock = mTransactionManagerMockRunReadCommitted{mock: m}
	m.RunReadCommittedMock.callArgs = []*TransactionManagerMockRunReadCommittedParams{}

	m.RunRepeatableReadMock = mTransactionManagerMockRunRepeatableRead{mock: m}
	m.RunRepeatableReadMock.callArgs = []*TransactionManagerMockRunRepeatableReadParams{}

	m.RunSerializableMock = mTransactionManagerMockRunSerializable{mock: m}
	m.RunSerializableMock.callArgs = []*TransactionManagerMockRunSerializableParams{}

	return m
}

type mTransactionManagerMockRunReadCommitted struct {
	mock               *TransactionManagerMock
	defaultExpectation *TransactionManagerMockRunReadCommittedExpectation
	expectations       []*TransactionManagerMockRunReadCommittedExpectation

	callArgs []*TransactionManagerMockRunReadCommittedParams
	mutex    sync.RWMutex
}

// TransactionManagerMockRunReadCommittedExpectation specifies expectation struct of the TransactionManager.RunReadCommitted
type TransactionManagerMockRunReadCommittedExpectation struct {
	mock    *TransactionManagerMock
	params  *TransactionManagerMockRunReadCommittedParams
	results *TransactionManagerMockRunReadCommittedResults
	Counter uint64
}

// TransactionManagerMockRunReadCommittedParams contains parameters of the TransactionManager.RunReadCommitted
type TransactionManagerMockRunReadCommittedParams struct {
	ctx context.Context
	fx  func(ctxTX context.Context) error
}

// TransactionManagerMockRunReadCommittedResults contains results of the TransactionManager.RunReadCommitted
type TransactionManagerMockRunReadCommittedResults struct {
	err error
}

// Expect sets up expected params for TransactionManager.RunReadCommitted
func (mmRunReadCommitted *mTransactionManagerMockRunReadCommitted) Expect(ctx context.Context, fx func(ctxTX context.Context) error) *mTransactionManagerMockRunReadCommitted {
	if mmRunReadCommitted.mock.funcRunReadCommitted != nil {
		mmRunReadCommitted.mock.t.Fatalf("TransactionManagerMock.RunReadCommitted mock is already set by Set")
	}

	if mmRunReadCommitted.defaultExpectation == nil {
		mmRunReadCommitted.defaultExpectation = &TransactionManagerMockRunReadCommittedExpectation{}
	}

	mmRunReadCommitted.defaultExpectation.params = &TransactionManagerMockRunReadCommittedParams{ctx, fx}
	for _, e := range mmRunReadCommitted.expectations {
		if minimock.Equal(e.params, mmRunReadCommitted.defaultExpectation.params) {
			mmRunReadCommitted.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRunReadCommitted.defaultExpectation.params)
		}
	}

	return mmRunReadCommitted
}

// Inspect accepts an inspector function that has same arguments as the TransactionManager.RunReadCommitted
func (mmRunReadCommitted *mTransactionManagerMockRunReadCommitted) Inspect(f func(ctx context.Context, fx func(ctxTX context.Context) error)) *mTransactionManagerMockRunReadCommitted {
	if mmRunReadCommitted.mock.inspectFuncRunReadCommitted != nil {
		mmRunReadCommitted.mock.t.Fatalf("Inspect function is already set for TransactionManagerMock.RunReadCommitted")
	}

	mmRunReadCommitted.mock.inspectFuncRunReadCommitted = f

	return mmRunReadCommitted
}

// Return sets up results that will be returned by TransactionManager.RunReadCommitted
func (mmRunReadCommitted *mTransactionManagerMockRunReadCommitted) Return(err error) *TransactionManagerMock {
	if mmRunReadCommitted.mock.funcRunReadCommitted != nil {
		mmRunReadCommitted.mock.t.Fatalf("TransactionManagerMock.RunReadCommitted mock is already set by Set")
	}

	if mmRunReadCommitted.defaultExpectation == nil {
		mmRunReadCommitted.defaultExpectation = &TransactionManagerMockRunReadCommittedExpectation{mock: mmRunReadCommitted.mock}
	}
	mmRunReadCommitted.defaultExpectation.results = &TransactionManagerMockRunReadCommittedResults{err}
	return mmRunReadCommitted.mock
}

// Set uses given function f to mock the TransactionManager.RunReadCommitted method
func (mmRunReadCommitted *mTransactionManagerMockRunReadCommitted) Set(f func(ctx context.Context, fx func(ctxTX context.Context) error) (err error)) *TransactionManagerMock {
	if mmRunReadCommitted.defaultExpectation != nil {
		mmRunReadCommitted.mock.t.Fatalf("Default expectation is already set for the TransactionManager.RunReadCommitted method")
	}

	if len(mmRunReadCommitted.expectations) > 0 {
		mmRunReadCommitted.mock.t.Fatalf("Some expectations are already set for the TransactionManager.RunReadCommitted method")
	}

	mmRunReadCommitted.mock.funcRunReadCommitted = f
	return mmRunReadCommitted.mock
}

// When sets expectation for the TransactionManager.RunReadCommitted which will trigger the result defined by the following
// Then helper
func (mmRunReadCommitted *mTransactionManagerMockRunReadCommitted) When(ctx context.Context, fx func(ctxTX context.Context) error) *TransactionManagerMockRunReadCommittedExpectation {
	if mmRunReadCommitted.mock.funcRunReadCommitted != nil {
		mmRunReadCommitted.mock.t.Fatalf("TransactionManagerMock.RunReadCommitted mock is already set by Set")
	}

	expectation := &TransactionManagerMockRunReadCommittedExpectation{
		mock:   mmRunReadCommitted.mock,
		params: &TransactionManagerMockRunReadCommittedParams{ctx, fx},
	}
	mmRunReadCommitted.expectations = append(mmRunReadCommitted.expectations, expectation)
	return expectation
}

// Then sets up TransactionManager.RunReadCommitted return parameters for the expectation previously defined by the When method
func (e *TransactionManagerMockRunReadCommittedExpectation) Then(err error) *TransactionManagerMock {
	e.results = &TransactionManagerMockRunReadCommittedResults{err}
	return e.mock
}

// RunReadCommitted implements services.TransactionManager
func (mmRunReadCommitted *TransactionManagerMock) RunReadCommitted(ctx context.Context, fx func(ctxTX context.Context) error) (err error) {
	mm_atomic.AddUint64(&mmRunReadCommitted.beforeRunReadCommittedCounter, 1)
	defer mm_atomic.AddUint64(&mmRunReadCommitted.afterRunReadCommittedCounter, 1)

	if mmRunReadCommitted.inspectFuncRunReadCommitted != nil {
		mmRunReadCommitted.inspectFuncRunReadCommitted(ctx, fx)
	}

	mm_params := &TransactionManagerMockRunReadCommittedParams{ctx, fx}

	// Record call args
	mmRunReadCommitted.RunReadCommittedMock.mutex.Lock()
	mmRunReadCommitted.RunReadCommittedMock.callArgs = append(mmRunReadCommitted.RunReadCommittedMock.callArgs, mm_params)
	mmRunReadCommitted.RunReadCommittedMock.mutex.Unlock()

	for _, e := range mmRunReadCommitted.RunReadCommittedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRunReadCommitted.RunReadCommittedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRunReadCommitted.RunReadCommittedMock.defaultExpectation.Counter, 1)
		mm_want := mmRunReadCommitted.RunReadCommittedMock.defaultExpectation.params
		mm_got := TransactionManagerMockRunReadCommittedParams{ctx, fx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRunReadCommitted.t.Errorf("TransactionManagerMock.RunReadCommitted got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRunReadCommitted.RunReadCommittedMock.defaultExpectation.results
		if mm_results == nil {
			mmRunReadCommitted.t.Fatal("No results are set for the TransactionManagerMock.RunReadCommitted")
		}
		return (*mm_results).err
	}
	if mmRunReadCommitted.funcRunReadCommitted != nil {
		return mmRunReadCommitted.funcRunReadCommitted(ctx, fx)
	}
	mmRunReadCommitted.t.Fatalf("Unexpected call to TransactionManagerMock.RunReadCommitted. %v %v", ctx, fx)
	return
}

// RunReadCommittedAfterCounter returns a count of finished TransactionManagerMock.RunReadCommitted invocations
func (mmRunReadCommitted *TransactionManagerMock) RunReadCommittedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRunReadCommitted.afterRunReadCommittedCounter)
}

// RunReadCommittedBeforeCounter returns a count of TransactionManagerMock.RunReadCommitted invocations
func (mmRunReadCommitted *TransactionManagerMock) RunReadCommittedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRunReadCommitted.beforeRunReadCommittedCounter)
}

// Calls returns a list of arguments used in each call to TransactionManagerMock.RunReadCommitted.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRunReadCommitted *mTransactionManagerMockRunReadCommitted) Calls() []*TransactionManagerMockRunReadCommittedParams {
	mmRunReadCommitted.mutex.RLock()

	argCopy := make([]*TransactionManagerMockRunReadCommittedParams, len(mmRunReadCommitted.callArgs))
	copy(argCopy, mmRunReadCommitted.callArgs)

	mmRunReadCommitted.mutex.RUnlock()

	return argCopy
}

// MinimockRunReadCommittedDone returns true if the count of the RunReadCommitted invocations corresponds
// the number of defined expectations
func (m *TransactionManagerMock) MinimockRunReadCommittedDone() bool {
	for _, e := range m.RunReadCommittedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RunReadCommittedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRunReadCommittedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRunReadCommitted != nil && mm_atomic.LoadUint64(&m.afterRunReadCommittedCounter) < 1 {
		return false
	}
	return true
}

// MinimockRunReadCommittedInspect logs each unmet expectation
func (m *TransactionManagerMock) MinimockRunReadCommittedInspect() {
	for _, e := range m.RunReadCommittedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionManagerMock.RunReadCommitted with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RunReadCommittedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRunReadCommittedCounter) < 1 {
		if m.RunReadCommittedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TransactionManagerMock.RunReadCommitted")
		} else {
			m.t.Errorf("Expected call to TransactionManagerMock.RunReadCommitted with params: %#v", *m.RunReadCommittedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRunReadCommitted != nil && mm_atomic.LoadUint64(&m.afterRunReadCommittedCounter) < 1 {
		m.t.Error("Expected call to TransactionManagerMock.RunReadCommitted")
	}
}

type mTransactionManagerMockRunRepeatableRead struct {
	mock               *TransactionManagerMock
	defaultExpectation *TransactionManagerMockRunRepeatableReadExpectation
	expectations       []*TransactionManagerMockRunRepeatableReadExpectation

	callArgs []*TransactionManagerMockRunRepeatableReadParams
	mutex    sync.RWMutex
}

// TransactionManagerMockRunRepeatableReadExpectation specifies expectation struct of the TransactionManager.RunRepeatableRead
type TransactionManagerMockRunRepeatableReadExpectation struct {
	mock    *TransactionManagerMock
	params  *TransactionManagerMockRunRepeatableReadParams
	results *TransactionManagerMockRunRepeatableReadResults
	Counter uint64
}

// TransactionManagerMockRunRepeatableReadParams contains parameters of the TransactionManager.RunRepeatableRead
type TransactionManagerMockRunRepeatableReadParams struct {
	ctx context.Context
	fx  func(ctxTX context.Context) error
}

// TransactionManagerMockRunRepeatableReadResults contains results of the TransactionManager.RunRepeatableRead
type TransactionManagerMockRunRepeatableReadResults struct {
	err error
}

// Expect sets up expected params for TransactionManager.RunRepeatableRead
func (mmRunRepeatableRead *mTransactionManagerMockRunRepeatableRead) Expect(ctx context.Context, fx func(ctxTX context.Context) error) *mTransactionManagerMockRunRepeatableRead {
	if mmRunRepeatableRead.mock.funcRunRepeatableRead != nil {
		mmRunRepeatableRead.mock.t.Fatalf("TransactionManagerMock.RunRepeatableRead mock is already set by Set")
	}

	if mmRunRepeatableRead.defaultExpectation == nil {
		mmRunRepeatableRead.defaultExpectation = &TransactionManagerMockRunRepeatableReadExpectation{}
	}

	mmRunRepeatableRead.defaultExpectation.params = &TransactionManagerMockRunRepeatableReadParams{ctx, fx}
	for _, e := range mmRunRepeatableRead.expectations {
		if minimock.Equal(e.params, mmRunRepeatableRead.defaultExpectation.params) {
			mmRunRepeatableRead.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRunRepeatableRead.defaultExpectation.params)
		}
	}

	return mmRunRepeatableRead
}

// Inspect accepts an inspector function that has same arguments as the TransactionManager.RunRepeatableRead
func (mmRunRepeatableRead *mTransactionManagerMockRunRepeatableRead) Inspect(f func(ctx context.Context, fx func(ctxTX context.Context) error)) *mTransactionManagerMockRunRepeatableRead {
	if mmRunRepeatableRead.mock.inspectFuncRunRepeatableRead != nil {
		mmRunRepeatableRead.mock.t.Fatalf("Inspect function is already set for TransactionManagerMock.RunRepeatableRead")
	}

	mmRunRepeatableRead.mock.inspectFuncRunRepeatableRead = f

	return mmRunRepeatableRead
}

// Return sets up results that will be returned by TransactionManager.RunRepeatableRead
func (mmRunRepeatableRead *mTransactionManagerMockRunRepeatableRead) Return(err error) *TransactionManagerMock {
	if mmRunRepeatableRead.mock.funcRunRepeatableRead != nil {
		mmRunRepeatableRead.mock.t.Fatalf("TransactionManagerMock.RunRepeatableRead mock is already set by Set")
	}

	if mmRunRepeatableRead.defaultExpectation == nil {
		mmRunRepeatableRead.defaultExpectation = &TransactionManagerMockRunRepeatableReadExpectation{mock: mmRunRepeatableRead.mock}
	}
	mmRunRepeatableRead.defaultExpectation.results = &TransactionManagerMockRunRepeatableReadResults{err}
	return mmRunRepeatableRead.mock
}

// Set uses given function f to mock the TransactionManager.RunRepeatableRead method
func (mmRunRepeatableRead *mTransactionManagerMockRunRepeatableRead) Set(f func(ctx context.Context, fx func(ctxTX context.Context) error) (err error)) *TransactionManagerMock {
	if mmRunRepeatableRead.defaultExpectation != nil {
		mmRunRepeatableRead.mock.t.Fatalf("Default expectation is already set for the TransactionManager.RunRepeatableRead method")
	}

	if len(mmRunRepeatableRead.expectations) > 0 {
		mmRunRepeatableRead.mock.t.Fatalf("Some expectations are already set for the TransactionManager.RunRepeatableRead method")
	}

	mmRunRepeatableRead.mock.funcRunRepeatableRead = f
	return mmRunRepeatableRead.mock
}

// When sets expectation for the TransactionManager.RunRepeatableRead which will trigger the result defined by the following
// Then helper
func (mmRunRepeatableRead *mTransactionManagerMockRunRepeatableRead) When(ctx context.Context, fx func(ctxTX context.Context) error) *TransactionManagerMockRunRepeatableReadExpectation {
	if mmRunRepeatableRead.mock.funcRunRepeatableRead != nil {
		mmRunRepeatableRead.mock.t.Fatalf("TransactionManagerMock.RunRepeatableRead mock is already set by Set")
	}

	expectation := &TransactionManagerMockRunRepeatableReadExpectation{
		mock:   mmRunRepeatableRead.mock,
		params: &TransactionManagerMockRunRepeatableReadParams{ctx, fx},
	}
	mmRunRepeatableRead.expectations = append(mmRunRepeatableRead.expectations, expectation)
	return expectation
}

// Then sets up TransactionManager.RunRepeatableRead return parameters for the expectation previously defined by the When method
func (e *TransactionManagerMockRunRepeatableReadExpectation) Then(err error) *TransactionManagerMock {
	e.results = &TransactionManagerMockRunRepeatableReadResults{err}
	return e.mock
}

// RunRepeatableRead implements services.TransactionManager
func (mmRunRepeatableRead *TransactionManagerMock) RunRepeatableRead(ctx context.Context, fx func(ctxTX context.Context) error) (err error) {
	mm_atomic.AddUint64(&mmRunRepeatableRead.beforeRunRepeatableReadCounter, 1)
	defer mm_atomic.AddUint64(&mmRunRepeatableRead.afterRunRepeatableReadCounter, 1)

	if mmRunRepeatableRead.inspectFuncRunRepeatableRead != nil {
		mmRunRepeatableRead.inspectFuncRunRepeatableRead(ctx, fx)
	}

	mm_params := &TransactionManagerMockRunRepeatableReadParams{ctx, fx}

	// Record call args
	mmRunRepeatableRead.RunRepeatableReadMock.mutex.Lock()
	mmRunRepeatableRead.RunRepeatableReadMock.callArgs = append(mmRunRepeatableRead.RunRepeatableReadMock.callArgs, mm_params)
	mmRunRepeatableRead.RunRepeatableReadMock.mutex.Unlock()

	for _, e := range mmRunRepeatableRead.RunRepeatableReadMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRunRepeatableRead.RunRepeatableReadMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRunRepeatableRead.RunRepeatableReadMock.defaultExpectation.Counter, 1)
		mm_want := mmRunRepeatableRead.RunRepeatableReadMock.defaultExpectation.params
		mm_got := TransactionManagerMockRunRepeatableReadParams{ctx, fx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRunRepeatableRead.t.Errorf("TransactionManagerMock.RunRepeatableRead got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRunRepeatableRead.RunRepeatableReadMock.defaultExpectation.results
		if mm_results == nil {
			mmRunRepeatableRead.t.Fatal("No results are set for the TransactionManagerMock.RunRepeatableRead")
		}
		return (*mm_results).err
	}
	if mmRunRepeatableRead.funcRunRepeatableRead != nil {
		return mmRunRepeatableRead.funcRunRepeatableRead(ctx, fx)
	}
	mmRunRepeatableRead.t.Fatalf("Unexpected call to TransactionManagerMock.RunRepeatableRead. %v %v", ctx, fx)
	return
}

// RunRepeatableReadAfterCounter returns a count of finished TransactionManagerMock.RunRepeatableRead invocations
func (mmRunRepeatableRead *TransactionManagerMock) RunRepeatableReadAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRunRepeatableRead.afterRunRepeatableReadCounter)
}

// RunRepeatableReadBeforeCounter returns a count of TransactionManagerMock.RunRepeatableRead invocations
func (mmRunRepeatableRead *TransactionManagerMock) RunRepeatableReadBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRunRepeatableRead.beforeRunRepeatableReadCounter)
}

// Calls returns a list of arguments used in each call to TransactionManagerMock.RunRepeatableRead.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRunRepeatableRead *mTransactionManagerMockRunRepeatableRead) Calls() []*TransactionManagerMockRunRepeatableReadParams {
	mmRunRepeatableRead.mutex.RLock()

	argCopy := make([]*TransactionManagerMockRunRepeatableReadParams, len(mmRunRepeatableRead.callArgs))
	copy(argCopy, mmRunRepeatableRead.callArgs)

	mmRunRepeatableRead.mutex.RUnlock()

	return argCopy
}

// MinimockRunRepeatableReadDone returns true if the count of the RunRepeatableRead invocations corresponds
// the number of defined expectations
func (m *TransactionManagerMock) MinimockRunRepeatableReadDone() bool {
	for _, e := range m.RunRepeatableReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RunRepeatableReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRunRepeatableReadCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRunRepeatableRead != nil && mm_atomic.LoadUint64(&m.afterRunRepeatableReadCounter) < 1 {
		return false
	}
	return true
}

// MinimockRunRepeatableReadInspect logs each unmet expectation
func (m *TransactionManagerMock) MinimockRunRepeatableReadInspect() {
	for _, e := range m.RunRepeatableReadMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionManagerMock.RunRepeatableRead with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RunRepeatableReadMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRunRepeatableReadCounter) < 1 {
		if m.RunRepeatableReadMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TransactionManagerMock.RunRepeatableRead")
		} else {
			m.t.Errorf("Expected call to TransactionManagerMock.RunRepeatableRead with params: %#v", *m.RunRepeatableReadMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRunRepeatableRead != nil && mm_atomic.LoadUint64(&m.afterRunRepeatableReadCounter) < 1 {
		m.t.Error("Expected call to TransactionManagerMock.RunRepeatableRead")
	}
}

type mTransactionManagerMockRunSerializable struct {
	mock               *TransactionManagerMock
	defaultExpectation *TransactionManagerMockRunSerializableExpectation
	expectations       []*TransactionManagerMockRunSerializableExpectation

	callArgs []*TransactionManagerMockRunSerializableParams
	mutex    sync.RWMutex
}

// TransactionManagerMockRunSerializableExpectation specifies expectation struct of the TransactionManager.RunSerializable
type TransactionManagerMockRunSerializableExpectation struct {
	mock    *TransactionManagerMock
	params  *TransactionManagerMockRunSerializableParams
	results *TransactionManagerMockRunSerializableResults
	Counter uint64
}

// TransactionManagerMockRunSerializableParams contains parameters of the TransactionManager.RunSerializable
type TransactionManagerMockRunSerializableParams struct {
	ctx context.Context
	fx  func(ctxTX context.Context) error
}

// TransactionManagerMockRunSerializableResults contains results of the TransactionManager.RunSerializable
type TransactionManagerMockRunSerializableResults struct {
	err error
}

// Expect sets up expected params for TransactionManager.RunSerializable
func (mmRunSerializable *mTransactionManagerMockRunSerializable) Expect(ctx context.Context, fx func(ctxTX context.Context) error) *mTransactionManagerMockRunSerializable {
	if mmRunSerializable.mock.funcRunSerializable != nil {
		mmRunSerializable.mock.t.Fatalf("TransactionManagerMock.RunSerializable mock is already set by Set")
	}

	if mmRunSerializable.defaultExpectation == nil {
		mmRunSerializable.defaultExpectation = &TransactionManagerMockRunSerializableExpectation{}
	}

	mmRunSerializable.defaultExpectation.params = &TransactionManagerMockRunSerializableParams{ctx, fx}
	for _, e := range mmRunSerializable.expectations {
		if minimock.Equal(e.params, mmRunSerializable.defaultExpectation.params) {
			mmRunSerializable.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRunSerializable.defaultExpectation.params)
		}
	}

	return mmRunSerializable
}

// Inspect accepts an inspector function that has same arguments as the TransactionManager.RunSerializable
func (mmRunSerializable *mTransactionManagerMockRunSerializable) Inspect(f func(ctx context.Context, fx func(ctxTX context.Context) error)) *mTransactionManagerMockRunSerializable {
	if mmRunSerializable.mock.inspectFuncRunSerializable != nil {
		mmRunSerializable.mock.t.Fatalf("Inspect function is already set for TransactionManagerMock.RunSerializable")
	}

	mmRunSerializable.mock.inspectFuncRunSerializable = f

	return mmRunSerializable
}

// Return sets up results that will be returned by TransactionManager.RunSerializable
func (mmRunSerializable *mTransactionManagerMockRunSerializable) Return(err error) *TransactionManagerMock {
	if mmRunSerializable.mock.funcRunSerializable != nil {
		mmRunSerializable.mock.t.Fatalf("TransactionManagerMock.RunSerializable mock is already set by Set")
	}

	if mmRunSerializable.defaultExpectation == nil {
		mmRunSerializable.defaultExpectation = &TransactionManagerMockRunSerializableExpectation{mock: mmRunSerializable.mock}
	}
	mmRunSerializable.defaultExpectation.results = &TransactionManagerMockRunSerializableResults{err}
	return mmRunSerializable.mock
}

// Set uses given function f to mock the TransactionManager.RunSerializable method
func (mmRunSerializable *mTransactionManagerMockRunSerializable) Set(f func(ctx context.Context, fx func(ctxTX context.Context) error) (err error)) *TransactionManagerMock {
	if mmRunSerializable.defaultExpectation != nil {
		mmRunSerializable.mock.t.Fatalf("Default expectation is already set for the TransactionManager.RunSerializable method")
	}

	if len(mmRunSerializable.expectations) > 0 {
		mmRunSerializable.mock.t.Fatalf("Some expectations are already set for the TransactionManager.RunSerializable method")
	}

	mmRunSerializable.mock.funcRunSerializable = f
	return mmRunSerializable.mock
}

// When sets expectation for the TransactionManager.RunSerializable which will trigger the result defined by the following
// Then helper
func (mmRunSerializable *mTransactionManagerMockRunSerializable) When(ctx context.Context, fx func(ctxTX context.Context) error) *TransactionManagerMockRunSerializableExpectation {
	if mmRunSerializable.mock.funcRunSerializable != nil {
		mmRunSerializable.mock.t.Fatalf("TransactionManagerMock.RunSerializable mock is already set by Set")
	}

	expectation := &TransactionManagerMockRunSerializableExpectation{
		mock:   mmRunSerializable.mock,
		params: &TransactionManagerMockRunSerializableParams{ctx, fx},
	}
	mmRunSerializable.expectations = append(mmRunSerializable.expectations, expectation)
	return expectation
}

// Then sets up TransactionManager.RunSerializable return parameters for the expectation previously defined by the When method
func (e *TransactionManagerMockRunSerializableExpectation) Then(err error) *TransactionManagerMock {
	e.results = &TransactionManagerMockRunSerializableResults{err}
	return e.mock
}

// RunSerializable implements services.TransactionManager
func (mmRunSerializable *TransactionManagerMock) RunSerializable(ctx context.Context, fx func(ctxTX context.Context) error) (err error) {
	mm_atomic.AddUint64(&mmRunSerializable.beforeRunSerializableCounter, 1)
	defer mm_atomic.AddUint64(&mmRunSerializable.afterRunSerializableCounter, 1)

	if mmRunSerializable.inspectFuncRunSerializable != nil {
		mmRunSerializable.inspectFuncRunSerializable(ctx, fx)
	}

	mm_params := &TransactionManagerMockRunSerializableParams{ctx, fx}

	// Record call args
	mmRunSerializable.RunSerializableMock.mutex.Lock()
	mmRunSerializable.RunSerializableMock.callArgs = append(mmRunSerializable.RunSerializableMock.callArgs, mm_params)
	mmRunSerializable.RunSerializableMock.mutex.Unlock()

	for _, e := range mmRunSerializable.RunSerializableMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRunSerializable.RunSerializableMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRunSerializable.RunSerializableMock.defaultExpectation.Counter, 1)
		mm_want := mmRunSerializable.RunSerializableMock.defaultExpectation.params
		mm_got := TransactionManagerMockRunSerializableParams{ctx, fx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRunSerializable.t.Errorf("TransactionManagerMock.RunSerializable got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRunSerializable.RunSerializableMock.defaultExpectation.results
		if mm_results == nil {
			mmRunSerializable.t.Fatal("No results are set for the TransactionManagerMock.RunSerializable")
		}
		return (*mm_results).err
	}
	if mmRunSerializable.funcRunSerializable != nil {
		return mmRunSerializable.funcRunSerializable(ctx, fx)
	}
	mmRunSerializable.t.Fatalf("Unexpected call to TransactionManagerMock.RunSerializable. %v %v", ctx, fx)
	return
}

// RunSerializableAfterCounter returns a count of finished TransactionManagerMock.RunSerializable invocations
func (mmRunSerializable *TransactionManagerMock) RunSerializableAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRunSerializable.afterRunSerializableCounter)
}

// RunSerializableBeforeCounter returns a count of TransactionManagerMock.RunSerializable invocations
func (mmRunSerializable *TransactionManagerMock) RunSerializableBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRunSerializable.beforeRunSerializableCounter)
}

// Calls returns a list of arguments used in each call to TransactionManagerMock.RunSerializable.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRunSerializable *mTransactionManagerMockRunSerializable) Calls() []*TransactionManagerMockRunSerializableParams {
	mmRunSerializable.mutex.RLock()

	argCopy := make([]*TransactionManagerMockRunSerializableParams, len(mmRunSerializable.callArgs))
	copy(argCopy, mmRunSerializable.callArgs)

	mmRunSerializable.mutex.RUnlock()

	return argCopy
}

// MinimockRunSerializableDone returns true if the count of the RunSerializable invocations corresponds
// the number of defined expectations
func (m *TransactionManagerMock) MinimockRunSerializableDone() bool {
	for _, e := range m.RunSerializableMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RunSerializableMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRunSerializableCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRunSerializable != nil && mm_atomic.LoadUint64(&m.afterRunSerializableCounter) < 1 {
		return false
	}
	return true
}

// MinimockRunSerializableInspect logs each unmet expectation
func (m *TransactionManagerMock) MinimockRunSerializableInspect() {
	for _, e := range m.RunSerializableMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransactionManagerMock.RunSerializable with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RunSerializableMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRunSerializableCounter) < 1 {
		if m.RunSerializableMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TransactionManagerMock.RunSerializable")
		} else {
			m.t.Errorf("Expected call to TransactionManagerMock.RunSerializable with params: %#v", *m.RunSerializableMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRunSerializable != nil && mm_atomic.LoadUint64(&m.afterRunSerializableCounter) < 1 {
		m.t.Error("Expected call to TransactionManagerMock.RunSerializable")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TransactionManagerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockRunReadCommittedInspect()

		m.MinimockRunRepeatableReadInspect()

		m.MinimockRunSerializableInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TransactionManagerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TransactionManagerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockRunReadCommittedDone() &&
		m.MinimockRunRepeatableReadDone() &&
		m.MinimockRunSerializableDone()
}
